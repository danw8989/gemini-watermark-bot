"""Telegram bot handlers."""

from __future__ import annotations

import asyncio
import io
import logging
from collections import defaultdict

from PIL import Image
from telegram import Update
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)

from .watermark import remove_watermark

logger = logging.getLogger(__name__)

# Buffer media-group messages so we can process batches together.
# Maps media_group_id -> list of (Update, context) waiting to be handled.
_group_buffers: dict[str, list[Update]] = defaultdict(list)
_group_locks: dict[str, asyncio.Event] = {}

WELCOME = (
    "Hi! Send me an image generated by Google Gemini and I'll remove the "
    "watermark for you.\n\n"
    "You can send photos (compressed) or files (full resolution). "
    "Multiple images at once are supported too."
)


async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.message.reply_text(WELCOME)


async def _process_and_reply(message, photo_file, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Download an image, remove the watermark, and send it back."""
    raw = await photo_file.download_as_bytearray()
    img = Image.open(io.BytesIO(raw))
    cleaned = remove_watermark(img)

    buf = io.BytesIO()
    cleaned.save(buf, format="PNG")
    buf.seek(0)

    await message.reply_document(
        document=buf,
        filename="cleaned.png",
        reply_to_message_id=message.message_id,
    )


async def _handle_single(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Handle a single image (photo or document)."""
    msg = update.message
    status = await msg.reply_text("Processing...")

    try:
        if msg.document:
            if not (msg.document.mime_type or "").startswith("image/"):
                await status.edit_text("That doesn't look like an image. Please send a photo or image file.")
                return
            photo_file = await msg.document.get_file()
        else:
            photo_file = await msg.photo[-1].get_file()

        await _process_and_reply(msg, photo_file, context)
        await status.delete()
    except Exception:
        logger.exception("Failed to process image")
        await status.edit_text("Something went wrong while processing the image.")


async def _flush_group(media_group_id: str, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Process a collected batch of media-group messages."""
    updates = _group_buffers.pop(media_group_id, [])
    _group_locks.pop(media_group_id, None)
    if not updates:
        return

    first_msg = updates[0].message
    status = await first_msg.reply_text(f"Processing {len(updates)} images...")

    success = 0
    for upd in updates:
        msg = upd.message
        try:
            if msg.document:
                if not (msg.document.mime_type or "").startswith("image/"):
                    continue
                photo_file = await msg.document.get_file()
            else:
                photo_file = await msg.photo[-1].get_file()

            await _process_and_reply(msg, photo_file, context)
            success += 1
        except Exception:
            logger.exception("Failed to process image in group")

    if success == len(updates):
        await status.delete()
    else:
        await status.edit_text(f"Done — processed {success}/{len(updates)} images.")


async def handle_image(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Entry point for photos and image documents."""
    msg = update.message
    group_id = msg.media_group_id

    if group_id is None:
        await _handle_single(update, context)
        return

    # Media group — collect messages and schedule a flush.
    _group_buffers[group_id].append(update)
    if group_id not in _group_locks:
        _group_locks[group_id] = asyncio.Event()
        # Schedule the flush after a short delay so all messages arrive.
        context.application.job_queue.run_once(
            lambda ctx: asyncio.ensure_future(_flush_group(group_id, ctx)),
            when=1.0,
            name=f"flush_{group_id}",
        )


def build_app(token: str) -> Application:
    """Create and configure the bot application."""
    app = Application.builder().token(token).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.PHOTO | filters.Document.IMAGE, handle_image))
    # Catch documents that aren't detected as images by the filter but were sent
    # as generic files — we'll check mime_type inside the handler.
    app.add_handler(MessageHandler(filters.Document.ALL, handle_image))
    return app
